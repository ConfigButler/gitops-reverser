# Sync Architecture Refactor: Event-Based Orphan Detection

## Overview

This document outlines a major architectural refactor of the GitOps Reverser sync mechanism. The current implementation has shared responsibility issues where BranchWorker components handle both event processing and orphan detection logic. The proposed solution introduces clean separation of concerns through event-based communication.

## Current Architecture Problems

### Mixed Responsibilities
The current `BranchWorker` violates single responsibility principle by handling:
- Event processing (core job)
- Git repository file listing (infrastructure concern)
- Orphan detection computation (business logic)
- DELETE event generation (output concern)

### Tight Coupling
- `BranchWorker` knows about Git filesystem operations
- `WatchManager` delegates orphan detection to workers
- No clear separation between "what exists in Git" vs "what should exist in cluster"

### Inverted Control Flow
```
WatchManager → SEED_SYNC event → BranchWorker lists files → computes orphans → generates DELETEs
```

This makes the system hard to test, debug, and extend.

## Proposed Solution: Event-Based Communication

### Core Concept
Replace direct method calls with event-based communication:
- **BranchWorker** reports facts: "Here's what I see in Git"
- **BaseFolderReconciler** ensures Git matches cluster state
- **EventRouter** coordinates communication

### Cluster-as-Source-of-Truth Reconciliation
The **BaseFolderReconciler** enforces that Git base folders reflect the current cluster state:
- **Adds missing resources**: Cluster resources not in Git → CREATE events
- **Full reconciliation**: Resources that need updating or are orphaned → RECONCILE_TO_CLUSTER event
- **Removes orphaned files**: Git files not in cluster → DELETE events
- **Fixes state drift**: Handles missed events, crashed pods, reconciliation of stale content
- **Time-aware safety**: Avoids conflicts with real-time event processing

**Note**: RECONCILE_TO_CLUSTER is a high-level event that triggers full reconciliation for a single resource. The WatchManager decides if reconciliation is needed based on timing.

### Benefits
1. **Clear Separation of Concerns**: Real-time events vs periodic reconciliation
2. **Better Testability**: Components can be tested in isolation
3. **Improved Observability**: Events provide audit trail
4. **Scalability**: Components can be scaled independently
5. **Race Condition Safety**: Time-based reconciliation prevents conflicts

## Event Types

### ClusterStateEvent
Reports cluster resources for a specific base folder scope.

```go
type ClusterStateEvent struct {
    // Repository identity (for routing)
    RepoName   string
    Branch     string
    BaseFolder string  // Specific base folder scope

    // Resources currently in cluster for this base folder
    Resources  []types.ResourceIdentifier  // Uses existing canonical type
}
```

### RepoStateEvent
Reports what Kubernetes resources exist in a Git repository branch.

```go
type RepoStateEvent struct {
    // Repository identity
    RepoName   string
    Branch     string
    BaseFolder string  // Specific base folder scope

    // Resources found in Git (parsed from YAML files)
    Resources  []types.ResourceIdentifier  // Uses existing canonical type
}
```

**Note**: Uses `types.ResourceIdentifier` (existing type) instead of a custom resource type. This provides consistency with the rest of the codebase and includes utility methods like `ToGitPath()`, `String()`, and `IsClusterScoped()`.

### Control Events
- `REQUEST_CLUSTER_STATE`: BaseFolderReconciler requests cluster snapshot from WatchManager
- `REQUEST_REPO_STATE`: Triggers RepoStateEvent emission for specific base folder
- `RECONCILE_TO_CLUSTER`: Triggers full reconciliation of base folder to current cluster state (WatchManager decides if needed based on last reconciliation time)
- `CREATE`: Generated by BaseFolderReconciler for missing resources (injected into watch pipeline)
- `DELETE`: Generated by BaseFolderReconciler for orphaned resources (injected into watch pipeline)

## Component Responsibilities

### WatchManager (Real-time Events + Reconciliation Safety)
**Responsibility**: Fast, low-latency processing of live cluster changes + reconciliation safety
- Processes Kubernetes watch events immediately
- **Updates `lastEventTimes` for race condition prevention**
- **Applies time-based filtering to reconciliation CREATE/DELETE events** from BaseFolderReconciler
- Forwards events to BranchWorkers for immediate Git commits
- **Does NOT** handle reconciliation logic or snapshots

### GitDestination Controller (BaseFolderReconciler Lifecycle)
**Responsibility**: Manages BaseFolderReconciler instances
- Creates BaseFolderReconciler when GitDestination becomes Ready
- One BaseFolderReconciler per (repo, branch, baseFolder) combination
- Registers BaseFolderReconciler with EventRouter
- **Cleanup behavior**: Currently only `Retain` (leave Git files untouched)
- Destroys BaseFolderReconciler when destination is deleted

### BranchWorker (Simplified)
**Before**: 4 responsibilities (process events + list files + compute orphans + generate deletes)
**After**: 2 responsibilities (process events + report repo state)

```go
func (w *BranchWorker) emitRepoState(repoConfig *configv1alpha1.GitRepoConfig, baseFolder string) error {
    // List YAML files in specific base folder
    paths, err := w.listYAMLPathsInBaseFolder(repoConfig, baseFolder)
    if err != nil {
        return err
    }

    // Parse into ResourceIdentifier structs
    var resources []types.ResourceIdentifier
    for _, path := range paths {
        if res, ok := parseIdentifierFromPath(path); ok {
            resources = append(resources, res)
        }
    }

    // Emit event (no decision making)
    event := RepoStateEvent{
        RepoName:   w.GitRepoConfigRef,
        Branch:     w.Branch,
        BaseFolder: baseFolder,
        Resources:  resources,
    }

    return w.emitEvent(event)
}
```

### BaseFolderReconciler (New Component)
**Responsibility**: Reconcile Git base folder to match cluster state (time-aware safety delegated to WatchManager)

```go
type BaseFolderReconciler struct {
    repoName   string
    branch     string
    baseFolder string

    // No time tracking - delegated to WatchManager for consistency
    // Focus purely on reconciliation logic
}

func (r *BaseFolderReconciler) OnClusterState(event ClusterStateEvent) {
    // Update cluster state snapshot
    r.clusterResources = event.Resources
    r.reconcileIfSafe()
}

func (r *BaseFolderReconciler) OnRepoState(event RepoStateEvent) {
    // Update Git state snapshot
    r.gitResources = event.Resources
    r.reconcileIfSafe()
}

func (r *BaseFolderReconciler) reconcile() {
    // Only reconcile when we have both cluster and Git state
    if r.clusterResources == nil || r.gitResources == nil {
        return
    }

    // Compute reconciliation actions (pure logic, no time concerns)
    toCreate := r.findMissingInGit(r.clusterResources, r.gitResources)
    toDelete := r.findOrphansInGit(r.clusterResources, r.gitResources)

    // Emit reconciliation events (time filtering happens in WatchManager)
    for _, resource := range toCreate {
        r.emitCreateEvent(resource) // WatchManager applies time filtering
    }
    for _, resource := range toDelete {
        r.emitDeleteEvent(resource) // WatchManager applies time filtering
    }

    // For updates and complex reconciliation, emit high-level event
    if r.needsFullReconciliation(r.clusterResources, r.gitResources) {
        r.emitReconcileToClusterEvent() // WatchManager decides if needed
    }
}
```

### EventRouter (Enhanced)
**Responsibility**: Route events between components

```go
func (r *EventRouter) SendRepoState(event RepoStateEvent) error {
    // Route to appropriate BaseFolderReconciler(s)
    return r.routeToReconcilers(event)
}

func (r *EventRouter) SendClusterState(event ClusterStateEvent) error {
    // Route cluster snapshots to reconcilers
    return r.routeToReconcilers(event)
}
```

## Event Flow

### New Flow (Targeted, Event-Based)
```
1. BaseFolderReconciler → REQUEST_CLUSTER_STATE("apps") → WatchManager
2. WatchManager → ClusterStateEvent("apps", resources) → BaseFolderReconciler
3. BaseFolderReconciler → REQUEST_REPO_STATE("apps") → EventRouter
4. EventRouter → BranchWorker for (repo, branch)
5. BranchWorker → RepoStateEvent("apps", resources) → EventRouter
6. EventRouter → BaseFolderReconciler for ("repo", "branch", "apps")
7. BaseFolderReconciler → compares cluster vs Git → CREATE/DELETE/RECONCILE_TO_CLUSTER events → WatchManager
8. WatchManager → applies time filtering to CREATE/DELETE events, decides on RECONCILE_TO_CLUSTER → injects into watch pipeline
9. Watch pipeline → processes events → BranchWorker → executes Git operations
```

### Comparison with Current Flow
**Current (Global, Direct):**
```
WatchManager → SEED_SYNC → BranchWorker lists ALL files → computes ALL orphans → generates ALL deletes
```

**New (Targeted, Event-Based):**
```
OrphanDetector → REQUEST_REPO_STATE("apps") → BranchWorker lists apps/ files → RepoStateEvent → OrphanDetector compares → targeted DELETEs
```

## Base Folder Scoping

### Why Per-BaseFolder Events?
- **Safety**: BaseFolder A cannot affect BaseFolder B's resources
- **Performance**: Smaller comparison sets, parallel processing
- **Precision**: Each GitDestination manages its own scope

### Implementation
- One `RepoStateEvent` per base folder
- One `OrphanDetector` per (repo, branch, baseFolder) combination
- Targeted `emitRepoState(baseFolder)` method

## Migration Strategy

### Phase 1: Add Event Types & BaseFolderReconciler Package
- Define `RepoStateEvent` and `ClusterStateEvent` structs (uses existing `types.ResourceIdentifier`)
- Add `REQUEST_CLUSTER_STATE` and `REQUEST_REPO_STATE` control events
- **Create `internal/reconcile/` package** (separate from existing code)
- Implement BaseFolderReconciler with pure reconciliation logic
- **Write comprehensive unit tests first** (test reconciliation logic in isolation)
- **Write integration tests** (test event handling and state management)
- **Get feedback on interfaces and tests** before integration

### Phase 2: Implement BaseFolderReconciler Lifecycle Management
- **GitDestination Controller creates BaseFolderReconciler instances** when destinations become Ready
- One BaseFolderReconciler per (repo, branch, baseFolder) combination
- Register with EventRouter for event delivery
- Handle cleanup when destinations are deleted

### Phase 3: Modify WatchManager for Reconciliation Events
- Add time-based filtering for reconciliation CREATE/DELETE events
- Update `lastEventTimes` tracking for race condition prevention
- Inject filtered reconciliation events into watch pipeline

### Phase 4: Modify BranchWorker
- Add `emitRepoState(baseFolder)` method
- Replace `handleSeedSync` with event-based triggering
- Keep existing functionality during transition

### Phase 5: Update EventRouter
- Add routing for `RepoStateEvent`s and `ClusterStateEvent`s
- Support per-baseFolder event delivery to BaseFolderReconcilers

### Phase 6: Integration Testing
- Test end-to-end event flow
- Verify orphan detection accuracy
- Performance testing with multiple base folders
- Test BaseFolderReconciler lifecycle (create/destroy)

### Phase 7: Remove Legacy Code
- Remove old SEED_SYNC handling
- Clean up shared responsibility code

## Testing Strategy

### Unit Tests (BaseFolderReconciler Package Only)
```go
func TestBaseFolderReconciler_ReconcileSafe(t *testing.T) {
    // Test reconciliation logic with time-aware safety
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")
    reconciler.SetGracePeriod(30 * time.Second)

    // Simulate cluster and Git state
    clusterResources := []types.ResourceIdentifier{...}
    gitResources := []types.ResourceIdentifier{...}

    // Test reconciliation produces correct CREATE/DELETE/RECONCILE_TO_CLUSTER events
    // Events are injected into watch pipeline for processing
    events := reconciler.Reconcile(clusterResources, gitResources)
    assert.Contains(t, events, expectedCreateEvent)
    assert.Contains(t, events, expectedDeleteEvent)
    if needsFullReconciliation {
        assert.Contains(t, events, expectedReconcileToClusterEvent)
    }
}

func TestBaseFolderReconciler_FindDifferences(t *testing.T) {
    // Test pure reconciliation logic (no time concerns)
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")

    clusterResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"},
        {Group: "", Version: "v1", Resource: "services", Name: "app-svc"},
    }
    gitResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"}, // exists in both
        {Group: "", Version: "v1", Resource: "configmaps", Name: "old-config"}, // orphan
    }

    toCreate, toUpdate, toDelete := reconciler.FindDifferences(clusterResources, gitResources)

    assert.Contains(t, toCreate, clusterResources[1]) // service missing from Git
    assert.Contains(t, toDelete, gitResources[1])     // configmap orphan in Git
    assert.Empty(t, toUpdate) // No updates in this simple case
}
```

### Integration Tests
- End-to-end sync testing
- Multi-base-folder scenarios
- Concurrent operation testing

## Benefits Summary

1. **Architectural Clarity**: Single responsibility per component
2. **Testability**: Isolated unit testing of each concern
3. **Maintainability**: Changes to orphan logic don't affect Git operations
4. **Scalability**: Independent scaling of components
5. **Observability**: Event-based audit trail
6. **Safety**: Per-base-folder isolation prevents cross-contamination
7. **Performance**: Targeted operations instead of global scans

## Risk Mitigation

- **Backward Compatibility**: Keep existing SEED_SYNC during transition
- **Gradual Rollout**: Phase implementation with feature flags
- **Comprehensive Testing**: Extensive test coverage before removing legacy code
- **Monitoring**: Add metrics for event flow and performance

## Future Extensions

- **Git Metadata**: Add commit author, timestamp to `ResourceIdentifier`
- **Selective Sync**: Sync only changed base folders
- **Parallel Processing**: Multiple BaseFolderReconcilers per branch
- **Caching**: Cache repo state to reduce Git operations
- **Cleanup Policies**: Implement `cleanupPolicy` field on GitDestination CRD (future feature) -> do make sure to model this the fluxcd way, I expect to have two extra fields on the GitDestinationo CRD
  - ```yaml
    # prune: When true (default), the operator will delete the corresponding 
    # file from Git when a managed resource is deleted from the cluster.
    # Set to false to disable this behavior, which will "orphan" the
    # file in Git, leaving it behind after its cluster resource is gone.
    prune: true
    ```
  - ```yaml
    # cleanupPolicy: Controls what happens to all managed files in Git
    # when this GitDestination resource itself is deleted.
    #
    # "Orphan" (default): Deleting this GitDestination CR will leave
    # all previously synced files in the Git repository.
    #
    # "Prune": Deleting this GitDestination CR will trigger a
    # final "cleanup" commit that deletes all files it was managing
    # from the Git repository.
    cleanupPolicy: "Orphan"
    ```
