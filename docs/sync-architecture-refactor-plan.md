# Sync Architecture Refactor: Event-Based Orphan Detection

## Overview

This document outlines a major architectural refactor of the GitOps Reverser sync mechanism. The current implementation has shared responsibility issues where BranchWorker components handle both event processing and orphan detection logic. The proposed solution introduces clean separation of concerns through event-based communication.

## Current Architecture Problems

### Mixed Responsibilities
The current `BranchWorker` violates single responsibility principle by handling:
- Event processing (core job)
- Git repository file listing (infrastructure concern)
- Orphan detection computation (business logic)
- DELETE event generation (output concern)

### Tight Coupling
- `BranchWorker` knows about Git filesystem operations
- `WatchManager` delegates orphan detection to workers
- No clear separation between "what exists in Git" vs "what should exist in cluster"

### Inverted Control Flow
```
WatchManager → SEED_SYNC event → BranchWorker lists files → computes orphans → generates DELETEs
```

This makes the system hard to test, debug, and extend.

## Proposed Solution: Event-Based Communication

### Core Concept
Replace direct method calls with event-based communication:
- **BranchWorker** reports facts: "Here's what I see in Git"
- **BaseFolderReconciler** ensures Git matches cluster state
- **EventRouter** coordinates communication

### Cluster-as-Source-of-Truth Reconciliation
The **BaseFolderReconciler** enforces that Git base folders reflect the current cluster state:
- **Adds missing resources**: Cluster resources not in Git → CREATE events
- **Full reconciliation**: Resources that exist in both cluster and Git → RECONCILE_RESOURCE event (reminder to check if updates needed)
- **Removes orphaned files**: Git files not in cluster → DELETE events
- **Fixes state drift**: Handles missed events, crashed pods, reconciliation of stale content
- **Time-aware safety**: Avoids conflicts with real-time event processing

**Note**: RECONCILE_RESOURCE is a reminder event for individual resources that exist in both cluster and Git. Other components can quickly ignore it if the resource doesn't actually need reconciliation.

### Benefits
1. **Clear Separation of Concerns**: Real-time events vs periodic reconciliation
2. **Better Testability**: Components can be tested in isolation
3. **Improved Observability**: Events provide audit trail
4. **Scalability**: Components can be scaled independently
5. **Race Condition Safety**: Time-based reconciliation prevents conflicts

## Event Types

### ClusterStateEvent
Reports cluster resources for a specific base folder scope.

```go
type ClusterStateEvent struct {
    // Repository identity (for routing)
    RepoName   string
    Branch     string
    BaseFolder string  // Specific base folder scope

    // Resources currently in cluster for this base folder
    Resources  []types.ResourceIdentifier  // Uses existing canonical type
}
```

### RepoStateEvent
Reports what Kubernetes resources exist in a Git repository branch.

```go
type RepoStateEvent struct {
    // Repository identity
    RepoName   string
    Branch     string
    BaseFolder string  // Specific base folder scope

    // Resources found in Git (parsed from YAML files)
    Resources  []types.ResourceIdentifier  // Uses existing canonical type
}
```

**Note**: Uses `types.ResourceIdentifier` (existing type) instead of a custom resource type. This provides consistency with the rest of the codebase and includes utility methods like `ToGitPath()`, `String()`, and `IsClusterScoped()`.

### Control Events
- `REQUEST_CLUSTER_STATE`: BaseFolderReconciler requests cluster snapshot from WatchManager
- `REQUEST_REPO_STATE`: Triggers RepoStateEvent emission for specific base folder
- `RECONCILE_RESOURCE`: Reminder event for a specific resource that may need reconciliation (other components can ignore if not applicable)
- `CREATE`: Generated by BaseFolderReconciler for missing resources (injected into watch pipeline)
- `DELETE`: Generated by BaseFolderReconciler for orphaned resources (injected into watch pipeline)

## Component Responsibilities

### WatchManager (Real-time Events)
**Responsibility**: Fast, low-latency processing of live cluster changes
- Processes Kubernetes watch events immediately
- Forwards events to GitDestinationEventStreams (not directly to BranchWorkers)
- Provides cluster state snapshots on request
- **Does NOT** handle reconciliation logic, snapshots, or time-based filtering

### GitDestination Controller (BaseFolderReconciler + GitDestinationEventStream Lifecycle)
**Responsibility**: Manages BaseFolderReconciler and GitDestinationEventStream instances
- Creates BaseFolderReconciler when GitDestination becomes Ready
- Creates GitDestinationEventStream when GitDestination becomes Ready
- One BaseFolderReconciler per (repo, branch, baseFolder) combination
- One GitDestinationEventStream per GitDestination
- Registers components with EventRouter
- **Cleanup behavior**: Currently only `Retain` (leave Git files untouched)
- Destroys components when destination is deleted

### BranchWorker (Simplified)
**Before**: 4 responsibilities (process events + list files + compute orphans + generate deletes)
**After**: 2 responsibilities (process events + report repo state)

```go
func (w *BranchWorker) emitRepoState(repoConfig *configv1alpha1.GitRepoConfig, baseFolder string) error {
    // List YAML files in specific base folder
    paths, err := w.listYAMLPathsInBaseFolder(repoConfig, baseFolder)
    if err != nil {
        return err
    }

    // Parse into ResourceIdentifier structs
    var resources []types.ResourceIdentifier
    for _, path := range paths {
        if res, ok := parseIdentifierFromPath(path); ok {
            resources = append(resources, res)
        }
    }

    // Emit event (no decision making)
    event := RepoStateEvent{
        RepoName:   w.GitRepoConfigRef,
        Branch:     w.Branch,
        BaseFolder: baseFolder,
        Resources:  resources,
    }

    return w.emitEvent(event)
}
```

**Note**: This method has been implemented in the BranchWorker. The `listYAMLPathsInBaseFolder` and `parseIdentifierFromPath` functions are implemented, and the event emission is handled through the EventRouter.

### GitDestinationEventStream (New Component)
**Responsibility**: Synchronize live event stream with reconciliation process (deterministic state machine)
- **State Machine**: STARTUP_RECONCILE → LIVE_PROCESSING
- **Event Buffering**: Buffers live events during initial reconciliation
- **Completion Signaling**: Tracks when BaseFolderReconciler finishes reconciliation
- **Event Hash Deduplication**: Tracks event hashes per ResourceIdentifier to prevent duplicate processing
- **Direct to BranchWorker**: Forwards processed events directly to BranchWorker for commits

### BaseFolderReconciler (New Component)
**Responsibility**: Reconcile Git base folder to match cluster state (deterministic safety via GitDestinationEventStream)

```go
type BaseFolderReconciler struct {
	repoName   string
	branch     string
	baseFolder string

	// Current state snapshots
	clusterResources []types.ResourceIdentifier
	gitResources     []types.ResourceIdentifier

	// Dependencies for event emission
	eventEmitter events.ReconcileEventEmitter
	logger       logr.Logger
}
```

func (r *BaseFolderReconciler) OnClusterState(event ClusterStateEvent) {
    if r.matchesEvent(event) {
        r.clusterResources = event.Resources
        r.reconcile()
    }
}

func (r *BaseFolderReconciler) OnRepoState(event RepoStateEvent) {
    if r.matchesEvent(event) {
        r.gitResources = event.Resources
        r.reconcile()
    }
}

func (r *BaseFolderReconciler) reconcile() {
    // Only reconcile when we have both cluster and Git state
    if r.clusterResources == nil || r.gitResources == nil {
        return
    }

    // Compute reconciliation actions (pure logic, no time concerns)
    toCreate, toDelete, existingInBoth := r.findDifferences(r.clusterResources, r.gitResources)

    r.logger.V(1).Info("Reconciliation computed",
        "toCreate", len(toCreate),
        "toDelete", len(toDelete),
        "existingInBoth", len(existingInBoth))

    // Emit reconciliation events (time filtering happens in WatchManager)
    for _, resource := range toCreate {
        if err := r.eventEmitter.EmitCreateEvent(resource); err != nil {
            r.logger.Error(err, "Failed to emit create event", "resource", resource.String())
        }
    }

    for _, resource := range toDelete {
        if err := r.eventEmitter.EmitDeleteEvent(resource); err != nil {
            r.logger.Error(err, "Failed to emit delete event", "resource", resource.String())
        }
    }

    // For resources that exist in both places, emit reconcile event immediately
    for _, resource := range existingInBoth {
        if err := r.eventEmitter.EmitReconcileResourceEvent(resource); err != nil {
            r.logger.Error(err, "Failed to emit reconcile resource event", "resource", resource.String())
        }
    }
}
```

### EventRouter (Enhanced)
**Responsibility**: Route events between components

```go
func (r *EventRouter) SendRepoState(event RepoStateEvent) error {
    // Route to appropriate BaseFolderReconciler(s)
    return r.routeToReconcilers(event)
}

func (r *EventRouter) SendClusterState(event ClusterStateEvent) error {
    // Route cluster snapshots to reconcilers
    return r.routeToReconcilers(event)
}

func (r *EventRouter) SendToGitDestinationEventStream(event WatchEvent, gitDestName string) error {
    // Route live events to specific GitDestinationEventStream
    return r.routeToEventStream(event, gitDestName)
}
```

## Event Flow

### New Flow (Targeted, Event-Based)
```
1. BaseFolderReconciler → REQUEST_CLUSTER_STATE("apps") → WatchManager
2. WatchManager → ClusterStateEvent("apps", resources) → BaseFolderReconciler
3. BaseFolderReconciler → REQUEST_REPO_STATE("apps") → EventRouter
4. EventRouter → BranchWorker for (repo, branch)
5. BranchWorker → RepoStateEvent("apps", resources) → EventRouter
6. EventRouter → BaseFolderReconciler for ("repo", "branch", "apps")
7. BaseFolderReconciler → compares cluster vs Git → CREATE/DELETE/RECONCILE_RESOURCE events → GitDestinationEventStream
8. GitDestinationEventStream → buffers events during STARTUP_RECONCILE, forwards immediately during LIVE_PROCESSING → BranchWorker
9. BranchWorker → executes Git operations (reconciliation events get combined into single commit if possible)
```

### Comparison with Current Flow
**Current (Global, Direct):**
```
WatchManager → SEED_SYNC → BranchWorker lists ALL files → computes ALL orphans → generates ALL deletes
```

**New (Targeted, Event-Based):**
```
BaseFolderReconciler → REQUEST_REPO_STATE("apps") → BranchWorker lists apps/ files → RepoStateEvent → BaseFolderReconciler compares → targeted CREATE/DELETE/RECONCILE_RESOURCE events
```

## Base Folder Scoping

### Why Per-BaseFolder Events?
- **Safety**: BaseFolder A cannot affect BaseFolder B's resources
- **Performance**: Smaller comparison sets, parallel processing
- **Precision**: Each GitDestination manages its own scope

### Implementation
- One `RepoStateEvent` per base folder
- One `BaseFolderReconciler` per (repo, branch, baseFolder) combination
- Targeted `emitRepoState(baseFolder)` method

## Migration Strategy

### Phase 1: Add Event Types & BaseFolderReconciler Package ✅ COMPLETED
- Define `RepoStateEvent` and `ClusterStateEvent` structs (uses existing `types.ResourceIdentifier`)
- Add `REQUEST_CLUSTER_STATE` and `REQUEST_REPO_STATE` control events
- **Create `internal/reconcile/` package** (separate from existing code)
- Implement BaseFolderReconciler with pure reconciliation logic
- **Write comprehensive unit tests first** (test reconciliation logic in isolation)
- **Write integration tests** (test event handling and state management)
- **Get feedback on interfaces and tests** before integration

### Phase 2: Implement BaseFolderReconciler Lifecycle Management ✅ COMPLETED
- **GitDestination Controller creates BaseFolderReconciler instances** when destinations become Ready
- One BaseFolderReconciler per (repo, branch, baseFolder) combination
- Register with EventRouter for event delivery
- Handle cleanup when destinations are deleted

### Phase 3: Implement GitDestinationEventStream Component
- Create `internal/reconcile/git_destination_event_stream.go`
- Implement state machine: STARTUP_RECONCILE → LIVE_PROCESSING
- Add event buffering during reconciliation phase
- Add completion signaling from BaseFolderReconciler
- Route events directly to BranchWorker (bypass WatchManager time filtering)
- Combine reconciliation events into single commit when possible

### Phase 4: Modify BranchWorker
- Add `emitRepoState(baseFolder)` method ✅ COMPLETED
- Replace `handleSeedSync` with event-based triggering
- Keep existing functionality during transition

### Phase 5: Update EventRouter
- Add routing for `RepoStateEvent`s and `ClusterStateEvent`s
- Support per-baseFolder event delivery to BaseFolderReconcilers
- Add routing to GitDestinationEventStreams

### Phase 6: Integration Testing
- Test end-to-end event flow with GitDestinationEventStream
- Verify orphan detection accuracy
- Test state machine transitions (STARTUP_RECONCILE → LIVE_PROCESSING)
- Test event buffering and replay
- Performance testing with multiple base folders
- Test component lifecycle (create/destroy)

### Phase 7: Remove Legacy Code
- Remove old SEED_SYNC handling
- Clean up shared responsibility code

## Testing Strategy

### Unit Tests (BaseFolderReconciler Package Only)
```go
func TestBaseFolderReconciler_FindDifferences(t *testing.T) {
    // Test pure reconciliation logic (no time concerns)
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")

    clusterResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"},
        {Group: "", Version: "v1", Resource: "services", Name: "app-svc"},
    }
    gitResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"}, // exists in both
        {Group: "", Version: "v1", Resource: "configmaps", Name: "old-config"}, // orphan
    }

    toCreate, toDelete, existingInBoth := reconciler.FindDifferences(clusterResources, gitResources)

    assert.Contains(t, toCreate, clusterResources[1]) // service missing from Git
    assert.Contains(t, toDelete, gitResources[1])     // configmap orphan in Git
    assert.Contains(t, existingInBoth, clusterResources[0]) // pod exists in both
}

func TestBaseFolderReconciler_GenerateEvents(t *testing.T) {
    // Test event generation from reconciliation results
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")

    toCreate := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "services", Name: "app-svc"},
    }
    toDelete := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "configmaps", Name: "old-config"},
    }
    needsReconciliation := true

    // Events are emitted directly in reconcile(), not through GenerateEvents
    // Test would verify that the correct events were emitted via the eventEmitter
}

func TestBaseFolderReconciler_OnStateEvents(t *testing.T) {
    // Test handling of cluster and repo state events
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")

    // Receive cluster state
    clusterEvent := ClusterStateEvent{
        RepoName:   "repo",
        Branch:     "main",
        BaseFolder: "apps",
        Resources: []types.ResourceIdentifier{
            {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"},
        },
    }
    reconciler.OnClusterState(clusterEvent)

    // Receive repo state
    repoEvent := RepoStateEvent{
        RepoName:   "repo",
        Branch:     "main",
        BaseFolder: "apps",
        Resources: []types.ResourceIdentifier{
            {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"},
            {Group: "", Version: "v1", Resource: "configmaps", Name: "old-config"},
        },
    }
    reconciler.OnRepoState(repoEvent)

    // Verify reconciliation was triggered
    // (In real implementation, this would emit events)
    assert.True(t, reconciler.HasBothStates())
}

func TestBaseFolderReconciler_EventEmission(t *testing.T) {
    // Test that RECONCILE_RESOURCE is emitted for resources that exist in both places
    reconciler := NewBaseFolderReconciler("repo", "branch", "apps")

    clusterResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"},
    }
    gitResources := []types.ResourceIdentifier{
        {Group: "", Version: "v1", Resource: "pods", Name: "app-pod"}, // exists in both
    }

    toCreate, toDelete, existingInBoth := reconciler.FindDifferences(clusterResources, gitResources)

    assert.Empty(t, toCreate)     // Nothing to create
    assert.Empty(t, toDelete)     // Nothing to delete
    assert.Contains(t, existingInBoth, clusterResources[0]) // RECONCILE_RESOURCE event will be emitted for this resource
}
```

### Integration Tests
- End-to-end sync testing
- Multi-base-folder scenarios
- Concurrent operation testing

## Benefits Summary

1. **Architectural Clarity**: Single responsibility per component
2. **Deterministic Behavior**: State machine eliminates race conditions and timing issues
3. **Event Buffering**: Clean separation between reconciliation and live processing
4. **Testability**: Isolated unit testing of each concern
5. **Maintainability**: Changes to orphan logic don't affect Git operations
6. **Scalability**: Independent scaling of components
7. **Observability**: Event-based audit trail with state machine visibility
8. **Safety**: Per-base-folder isolation prevents cross-contamination
9. **Performance**: Targeted operations instead of global scans, combined reconciliation commits

## Risk Mitigation

- **No Persistence**: MVP approach - pod restart means reconciliation restart (acceptable for initial implementation)
- **Deterministic State Machine**: GitDestinationEventStream provides predictable behavior instead of time-based filtering
- **Event Hash Deduplication**: GitDestinationEventStream tracks event hashes per ResourceIdentifier to prevent duplicate event processing
- **Push Rate Limiting**: Keep existing `pushInterval` and `maxCommits` configuration to prevent excessive Git operations
- **Backward Compatibility**: Keep existing SEED_SYNC during transition
- **Gradual Rollout**: Phase implementation with feature flags
- **Comprehensive Testing**: Extensive test coverage before removing legacy code
- **Monitoring**: Add metrics for event flow, state transitions, buffering, and deduplication

## Future Extensions

- **Selective Sync**: Sync only changed base folders
- **Parallel Processing**: Multiple BaseFolderReconcilers per branch
- **Caching**: Cache repo state to reduce Git operations
- **Cleanup Policies**: Implement `cleanupPolicy` field on GitDestination CRD (future feature) -> do make sure to model this the fluxcd way, I expect to have two extra fields on the GitDestinationo CRD
  - ```yaml
    # prune: When true (default), the operator will delete the corresponding 
    # file from Git when a managed resource is deleted from the cluster.
    # Set to false to disable this behavior, which will "orphan" the
    # file in Git, leaving it behind after its cluster resource is gone.
    prune: true
    ```
  - ```yaml
    # cleanupPolicy: Controls what happens to all managed files in Git
    # when this GitDestination resource itself is deleted.
    #
    # "Orphan" (default): Deleting this GitDestination CR will leave
    # all previously synced files in the Git repository.
    #
    # "Prune": Deleting this GitDestination CR will trigger a
    # final "cleanup" commit that deletes all files it was managing
    # from the Git repository.
    cleanupPolicy: "Orphan"
    ```
